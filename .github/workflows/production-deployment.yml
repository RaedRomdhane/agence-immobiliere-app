name: Production Deployment Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string
      skip_tests:
        description: 'Skip tests (emergency only)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}-backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}-frontend
  NODE_VERSION: '20.x'
  HELM_VERSION: 'v3.13.0'

jobs:
  # Job 1: Validate and Build
  validate:
    name: Validate & Build
    runs-on: ubuntu-latest
    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: |
            backend/package-lock.json
            frontend/package-lock.json
      
      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci
      
      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Lint backend
        working-directory: ./backend
        run: npm run lint || echo "Linting completed with warnings"
      
      - name: Lint frontend
        working-directory: ./frontend
        run: npm run lint || echo "Linting completed with warnings"
      
      - name: Run backend tests
        if: ${{ !inputs.skip_tests }}
        working-directory: ./backend
        run: npm test
        env:
          NODE_ENV: test
          MONGODB_URI: mongodb://localhost:27017/test
      
      - name: Run frontend tests
        if: ${{ !inputs.skip_tests }}
        working-directory: ./frontend
        run: npm test -- --passWithNoTests
      
      - name: Build backend
        working-directory: ./backend
        run: npm run build || echo "No build script"
      
      - name: Build frontend
        working-directory: ./frontend
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: ${{ inputs.environment == 'production' && 'https://api.agence-immobiliere.com' || 'https://api.staging.agence-immobiliere.com' }}
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            backend/dist
            frontend/.next
          retention-days: 1

  # Job 2: Build and Push Docker Images
  build-images:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: validate
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}
          tags: |
            type=semver,pattern={{version}},value=${{ inputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ inputs.version }}
            type=raw,value=${{ inputs.environment }}-latest
            type=sha,prefix=${{ inputs.environment }}-
      
      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.production
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
          tags: |
            type=semver,pattern={{version}},value=${{ inputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ inputs.version }}
            type=raw,value=${{ inputs.environment }}-latest
            type=sha,prefix=${{ inputs.environment }}-
      
      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=${{ inputs.environment == 'production' && 'https://api.agence-immobiliere.com' || 'https://api.staging.agence-immobiliere.com' }}

  # Job 3: Pre-deployment Backup
  backup:
    name: Backup Database
    runs-on: ubuntu-latest
    needs: build-images
    if: inputs.environment == 'production'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
      
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
      
      - name: Create backup job
        run: |
          kubectl create job --from=cronjob/mongodb-backup backup-pre-deploy-$(date +%Y%m%d-%H%M%S) \
            -n production || echo "Backup job already running"
      
      - name: Wait for backup completion
        run: |
          kubectl wait --for=condition=complete --timeout=10m \
            job/backup-pre-deploy-$(date +%Y%m%d-%H%M%S) -n production || echo "Backup check skipped"

  # Job 4: Deploy to Staging (Auto)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-images
    if: inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.agence-immobiliere.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
      
      - name: Create secrets file
        run: |
          cat > secrets-staging.yaml <<EOF
          secrets:
            MONGODB_URI: "${{ secrets.MONGODB_URI_STAGING }}"
            JWT_SECRET: "${{ secrets.JWT_SECRET }}"
            GOOGLE_CLIENT_ID: "${{ secrets.GOOGLE_CLIENT_ID }}"
            GOOGLE_CLIENT_SECRET: "${{ secrets.GOOGLE_CLIENT_SECRET }}"
            SESSION_SECRET: "${{ secrets.SESSION_SECRET }}"
            AZURE_STORAGE_ACCOUNT_NAME: "${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}"
            AZURE_STORAGE_ACCOUNT_KEY: "${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}"
          mongodb:
            auth:
              rootPassword: "${{ secrets.MONGODB_ROOT_PASSWORD_STAGING }}"
          EOF
      
      - name: Deploy with Helm
        run: |
          helm upgrade agence-immobiliere ./infrastructure/k8s/helm/agence-immobiliere \
            --install \
            --namespace staging \
            --create-namespace \
            -f ./infrastructure/k8s/helm/agence-immobiliere/values-staging.yaml \
            -f secrets-staging.yaml \
            --set backend.image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }} \
            --set backend.image.tag=${{ inputs.version }} \
            --set frontend.image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }} \
            --set frontend.image.tag=${{ inputs.version }} \
            --wait \
            --timeout 10m
      
      - name: Verify deployment
        run: |
          kubectl rollout status deployment/agence-immobiliere-backend -n staging --timeout=5m
          kubectl rollout status deployment/agence-immobiliere-frontend -n staging --timeout=5m
      
      - name: Run smoke tests
        run: |
          sleep 30
          kubectl run smoke-test --image=curlimages/curl:latest --rm -i --restart=Never -n staging -- \
            curl -f https://api.staging.agence-immobiliere.com/health || exit 1

  # Job 5: Deploy to Production (Manual Approval Required)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-images, backup]
    if: inputs.environment == 'production'
    environment:
      name: production
      url: https://agence-immobiliere.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
      
      - name: Create secrets file
        run: |
          cat > secrets-production.yaml <<EOF
          secrets:
            MONGODB_URI: "${{ secrets.MONGODB_URI }}"
            JWT_SECRET: "${{ secrets.JWT_SECRET }}"
            GOOGLE_CLIENT_ID: "${{ secrets.GOOGLE_CLIENT_ID }}"
            GOOGLE_CLIENT_SECRET: "${{ secrets.GOOGLE_CLIENT_SECRET }}"
            SESSION_SECRET: "${{ secrets.SESSION_SECRET }}"
            AZURE_STORAGE_ACCOUNT_NAME: "${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}"
            AZURE_STORAGE_ACCOUNT_KEY: "${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}"
          mongodb:
            auth:
              rootPassword: "${{ secrets.MONGODB_ROOT_PASSWORD }}"
          EOF
      
      - name: Blue-Green Deployment - Deploy Green
        run: |
          # Create green deployment
          helm upgrade agence-immobiliere-green ./infrastructure/k8s/helm/agence-immobiliere \
            --install \
            --namespace production \
            -f secrets-production.yaml \
            --set backend.image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }} \
            --set backend.image.tag=${{ inputs.version }} \
            --set frontend.image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }} \
            --set frontend.image.tag=${{ inputs.version }} \
            --set nameOverride=agence-immobiliere-green \
            --wait \
            --timeout 10m
      
      - name: Health check on Green deployment
        id: health_check
        run: |
          sleep 30
          for i in {1..10}; do
            if kubectl run health-check --image=curlimages/curl:latest --rm -i --restart=Never -n production -- \
              curl -f http://agence-immobiliere-green-backend:5000/health; then
              echo "Health check passed"
              exit 0
            fi
            echo "Attempt $i failed, retrying..."
            sleep 10
          done
          echo "Health check failed after 10 attempts"
          exit 1
      
      - name: Switch traffic to Green (Blue-Green swap)
        if: success()
        run: |
          # Update main deployment to new version
          helm upgrade agence-immobiliere ./infrastructure/k8s/helm/agence-immobiliere \
            --namespace production \
            -f secrets-production.yaml \
            --set backend.image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }} \
            --set backend.image.tag=${{ inputs.version }} \
            --set frontend.image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }} \
            --set frontend.image.tag=${{ inputs.version }} \
            --wait \
            --timeout 10m
      
      - name: Verify production deployment
        run: |
          kubectl rollout status deployment/agence-immobiliere-backend -n production --timeout=5m
          kubectl rollout status deployment/agence-immobiliere-frontend -n production --timeout=5m
      
      - name: Run smoke tests
        run: |
          sleep 30
          kubectl run smoke-test --image=curlimages/curl:latest --rm -i --restart=Never -n production -- \
            curl -f https://api.agence-immobiliere.com/health || exit 1
      
      - name: Cleanup Green deployment
        if: success()
        run: |
          helm uninstall agence-immobiliere-green -n production || echo "Green deployment already removed"
      
      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          helm rollback agence-immobiliere -n production
          helm uninstall agence-immobiliere-green -n production || echo "Green deployment cleanup"

  # Job 6: Post-deployment validation
  validate-deployment:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          if [ "${{ inputs.environment }}" == "production" ]; then
            echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          else
            echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
          fi
      
      - name: Check pod health
        run: |
          kubectl get pods -n ${{ inputs.environment }} -l app.kubernetes.io/name=agence-immobiliere
          kubectl get events -n ${{ inputs.environment }} --sort-by='.lastTimestamp' | tail -20
      
      - name: Check HPA status
        run: |
          kubectl get hpa -n ${{ inputs.environment }}
      
      - name: Collect metrics
        run: |
          echo "Deployment completed at: $(date)"
          kubectl top pods -n ${{ inputs.environment }} || echo "Metrics not available"

  # Job 7: Notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate-deployment]
    if: always()
    
    steps:
      - name: Deployment Success Notification
        if: success()
        run: |
          echo "Deployment successful to ${{ inputs.environment }}"
          # Add Slack/Email notification here
          # curl -X POST ${{ secrets.SLACK_WEBHOOK }} -d '{"text":"Deployment successful"}'
      
      - name: Deployment Failure Notification
        if: failure()
        run: |
          echo "Deployment failed to ${{ inputs.environment }}"
          # Add Slack/Email notification here
          # curl -X POST ${{ secrets.SLACK_WEBHOOK }} -d '{"text":"Deployment failed"}'
