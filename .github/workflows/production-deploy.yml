name: Production Deployment

on:
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (not recommended)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      skip_backup:
        description: 'Skip database backup (dangerous!)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

env:
  NODE_VERSION: '20.x'
  
jobs:
  # Job 1: Run tests
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: inputs.skip_tests == 'false'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: |
            backend/package-lock.json
            frontend/package-lock.json
      
      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci
      
      - name: Run backend linter
        working-directory: ./backend
        run: npm run lint
      
      - name: Run backend tests
        working-directory: ./backend
        run: npm test
      
      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Run frontend linter
        working-directory: ./frontend
        run: npm run lint
      
      - name: Build frontend
        working-directory: ./frontend
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL_PRODUCTION }}
          NEXT_PUBLIC_GOOGLE_MAPS_API_KEY: ${{ secrets.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY }}
  
  # Job 2: Backup database
  backup-database:
    name: Backup Database
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped') && inputs.skip_backup == 'false'
    
    outputs:
      backup_file: ${{ steps.backup.outputs.backup_file }}
      backup_hash: ${{ steps.backup.outputs.backup_hash }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install MongoDB tools
        run: |
          wget -qO - https://www.mongodb.org/static/pgp/server-7.0.asc | sudo apt-key add -
          echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list
          sudo apt-get update
          sudo apt-get install -y mongodb-database-tools jq
      
      - name: Create backup directory
        run: mkdir -p backups
      
      - name: Run backup script
        id: backup
        run: |
          chmod +x infrastructure/scripts/backup-mongodb.sh
          ./infrastructure/scripts/backup-mongodb.sh
        env:
          MONGODB_URI: ${{ secrets.MONGODB_URI_PRODUCTION }}
          BACKUP_DIR: ./backups
          GITHUB_OUTPUT: ${{ github.output }}
      
      - name: Upload backup artifact
        uses: actions/upload-artifact@v4
        with:
          name: mongodb-backup-${{ github.run_id }}
          path: backups/*.tar.gz
          retention-days: 30
      
      - name: Upload backup metadata
        uses: actions/upload-artifact@v4
        with:
          name: mongodb-backup-metadata-${{ github.run_id }}
          path: backups/*-metadata.json
          retention-days: 30
  
  # Job 3: Deploy to production (requires manual approval via environment protection)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [test, backup-database]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped') && (needs.backup-database.result == 'success' || needs.backup-database.result == 'skipped')
    environment:
      name: prod-deploy
      url: ${{ steps.deploy.outputs.backend_url }}
    
    outputs:
      backend_url: ${{ steps.deploy.outputs.backend_url }}
      frontend_url: ${{ steps.deploy.outputs.frontend_url }}
      deployment_tag: ${{ steps.tag.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create deployment tag
        id: tag
        run: |
          TAG="prod-$(date +'%Y%m%d-%H%M%S')"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${TAG}" -m "Production deployment ${TAG}"
          git push origin "${TAG}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
      
      - name: Deploy backend to Railway
        id: deploy-backend
        run: |
          npm install -g @railway/cli
          railway link ${{ secrets.RAILWAY_PROJECT_ID_PRODUCTION }}
          railway up --service backend --environment production
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      
      - name: Setup Node.js for frontend
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Deploy frontend to Vercel
        id: deploy-frontend
        working-directory: ./frontend
        run: |
          npm install -g vercel
          vercel --token ${{ secrets.VERCEL_TOKEN }} --prod --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID_PRODUCTION }}
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL_PRODUCTION }}
          NEXT_PUBLIC_GOOGLE_MAPS_API_KEY: ${{ secrets.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY }}
      
      - name: Set outputs
        id: deploy
        run: |
          echo "backend_url=${{ secrets.BACKEND_URL_PRODUCTION }}" >> $GITHUB_OUTPUT
          echo "frontend_url=${{ secrets.FRONTEND_URL_PRODUCTION }}" >> $GITHUB_OUTPUT
  
  # Job 4: Health checks
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Wait for deployment
        run: sleep 30
      
      - name: Run health check
        id: health
        run: |
          chmod +x infrastructure/scripts/health-check.sh
          ./infrastructure/scripts/health-check.sh
        env:
          BACKEND_URL: ${{ needs.deploy-production.outputs.backend_url }}
          FRONTEND_URL: ${{ needs.deploy-production.outputs.frontend_url }}
          HEALTH_CHECK_TIMEOUT: 30
          GITHUB_OUTPUT: ${{ github.output }}
      
      - name: Upload health report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-check-report-${{ github.run_id }}
          path: health-check-report-*.json
          retention-days: 30
      
      - name: Check health status
        run: |
          if [ "${{ steps.health.outputs.health_status }}" != "HEALTHY" ]; then
            echo "âŒ Health check failed! Status: ${{ steps.health.outputs.health_status }}"
            echo "Failed checks: ${{ steps.health.outputs.failed_checks }}"
            echo "Warning checks: ${{ steps.health.outputs.warning_checks }}"
            exit 1
          fi
  
  # Job 5: Notify on failure
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [test, backup-database, deploy-production, health-check]
    if: failure()
    
    steps:
      - name: Create failure comment
        uses: actions/github-script@v7
        with:
          script: |
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const body = `## âŒ Production Deployment Failed
            
            **Workflow Run:** ${runUrl}
            **Triggered by:** @${context.actor}
            **Commit:** ${context.sha.substring(0, 7)}
            
            **Failed Jobs:**
            - Test: ${{ needs.test.result }}
            - Backup: ${{ needs.backup-database.result }}
            - Deploy: ${{ needs.deploy-production.result }}
            - Health Check: ${{ needs.health-check.result }}
            
            **Next Steps:**
            1. Review the workflow logs
            2. If deployment succeeded but health checks failed, consider rollback
            3. Fix the issues and retry deployment
            
            **Rollback Command:**
            \`\`\`bash
            # If deployment was successful but health checks failed
            gh workflow run production-rollback.yml -f tag=${{ needs.deploy-production.outputs.deployment_tag }}
            \`\`\`
            `;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Production Deployment Failed - ${new Date().toISOString()}`,
              body: body,
              labels: ['deployment', 'production', 'critical']
            });
  
  # Job 6: Notify on success
  notify-success:
    name: Notify on Success
    runs-on: ubuntu-latest
    needs: [deploy-production, health-check]
    if: success()
    
    steps:
      - name: Create success summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## âœ… Production Deployment Successful
          
          **Deployment Tag:** \`${{ needs.deploy-production.outputs.deployment_tag }}\`
          **Backend URL:** ${{ needs.deploy-production.outputs.backend_url }}
          **Frontend URL:** ${{ needs.deploy-production.outputs.frontend_url }}
          
          **Health Check Results:**
          - Status: ${{ needs.health-check.outputs.health_status }}
          - Passed: ${{ needs.health-check.outputs.passed_checks }}
          - Failed: ${{ needs.health-check.outputs.failed_checks }}
          - Warnings: ${{ needs.health-check.outputs.warning_checks }}
          
          **Rollback Information:**
          If you need to rollback this deployment, use:
          \`\`\`bash
          gh workflow run production-rollback.yml -f tag=${{ needs.deploy-production.outputs.deployment_tag }}
          \`\`\`
          
          **Backup Information:**
          Database backup is available in artifacts for 30 days.
          EOF
